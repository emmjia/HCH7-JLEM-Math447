# creating data table
factorA = rep(c("-","+","-","+","-","+","-","+"), times = 3)
factorB = rep(c("-","-","+","+","-","-","+","+"), times = 3)
factorC = rep(c("-","-","-","-","+","+","+","+"), times = 3)
Rep = rep(c("I", "II", "III"), each = 8)
yield = c(22,32,35,55,44,40,60,39,31,43,34,47,45,37,50,41,25,29,50,46,38,36,54,47)
#dataframe
cutting.speed.long = data.frame(factorA, factorB, factorC, Rep, yield)
View(cutting.speed.long)
#############################################
##     Blocking a replicated design         #
#############################################
#Yield data (pp. 234)
yield=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/yield.txt", header = TRUE)
summary(aov(Yield ~ Rep + A * B, yield)) #analysis of design with blocking
summary(aov(Yield ~ A * B, yield)) # analysis of design without blocking
cutting.lm = summary(lm(yield ~ Rep + factorA * factorB * factorC, cutting.speed.long)); cutting.lm
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
# creating data table
factorA = rep(c("-","+","-","+","-","+","-","+"), times = 3)
factorB = rep(c("-","-","+","+","-","-","+","+"), times = 3)
factorC = rep(c("-","-","-","-","+","+","+","+"), times = 3)
Rep = rep(c("I", "II", "III"), each = 8)
yield = c(22,32,35,55,44,40,60,39,31,43,34,47,45,37,50,41,25,29,50,46,38,36,54,47)
#dataframe
cutting.speed.long = data.frame(factorA, factorB, factorC, Rep, yield)
cutting.lm = summary(lm(yield ~ Rep + factorA * factorB * factorC, cutting.speed.long)); cutting.lm
#############################################
##     Blocking a replicated design         #
#############################################
#Yield data (pp. 234)
yield=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/yield.txt", header = TRUE)
View(yield)
View(cutting.speed.long)
summary(aov(Yield ~ Rep + A * B, yield)) #analysis of design with blocking
View(yield)
View(cutting.lm)
cutting.lm = summary(lm(yield ~ Rep + factorA * factorB * factorC, cutting.speed.long)); cutting.lm
###############################################
##     confounding a 2^K desgin in 2 blocks ###
###############################################
#filtration rate data (eg. 6.2/7.2 page 257/310)
filtration=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/filtration.txt", header = TRUE)
for (j in 1:4)
filtration[, j]=as.numeric(coded(filtration[, j]))
#factors have already been converted from "-","+" to -1, +1 coding
#Note that ABCD cannot be estimated, because it is confounded with blocks
filtration$Block=filtration$A * filtration$B *filtration$C * filtration$D
summary(lm(Rate ~ Block + A * B * C * D, filtration))
View(filtration)
Rep
View(yield)
View(cutting.speed.long)
cutting.aov = aov(yield~Rep+factorA*factorB*factorC, cutting.speed.long)
summary(cutting.aov)
cutting.aov1 = aov(yield~factorA*factorB*factorC, cutting.speed.long)
summary(cutting.aov); summary(cutting.aov1)
# creating data table
A <- rep(c("-","+","-","+"), times = 4)
B <- rep(c("-","-","+","+"), times = 4)
Rep <- rep(c("I","II","III","IV"), each = 4)
Vibes <- c(18.2, 27.2, 15.9, 41.0, 18.9, 24.0, 14.5, 43.9, 12.9, 22.4, 15.1, 36.3, 14.4, 22.5, 14.2, 39.9)
router.long <- data.frame(A, B, Rep, Vibes)
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
###############################################
##     confounding a 2^K desgin in 2 blocks ###
###############################################
#filtration rate data (eg. 6.2/7.2 page 257/310)
filtration=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/filtration.txt", header = TRUE)
View(filtration)
for (j in 1:4)
filtration[, j]=as.numeric(coded(filtration[, j]))
View(filtration)
#######
router.long$Block=router.long$A * router.long$B
summary(lm(Vibes ~ Block + A * B * C * D, router.long))
summary(lm(Vibes ~ Block + A * B, router.long))
View(router.long)
View(filtration)
for (j in 1:2)
router.long[, j]=as.numeric(coded(router.long[, j]))
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
#######
router.long$Block=router.long$A * router.long$B
summary(lm(Vibes ~ Block + A * B, router.long))
View(router.long)
summary(lm(Vibes ~ Block + A * B, router.long))
#factors have already been converted from "-","+" to -1, +1 coding
#Note that ABCD cannot be estimated, because it is confounded with blocks
filtration$Block=filtration$A * filtration$B *filtration$C * filtration$D
summary(lm(Rate ~ Block + A * B * C * D, filtration))
###############################################
##     confounding a 2^K desgin in 2 blocks ###
###############################################
#filtration rate data (eg. 6.2/7.2 page 257/310)
filtration=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/filtration.txt", header = TRUE)
for (j in 1:4)
filtration[, j]=as.numeric(coded(filtration[, j]))
#factors have already been converted from "-","+" to -1, +1 coding
#Note that ABCD cannot be estimated, because it is confounded with blocks
filtration$Block=filtration$A * filtration$B *filtration$C * filtration$D
summary(lm(Rate ~ Block + A * B * C * D, filtration))
cutting.aov.og = aov(yield~factorA*factorB*factorC, cutting.speed.long)
summary(cutting.aov); summary(cutting.aov.og)
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
# creating data table
factorA = rep(c("-","+","-","+","-","+","-","+"), times = 3)
factorB = rep(c("-","-","+","+","-","-","+","+"), times = 3)
factorC = rep(c("-","-","-","-","+","+","+","+"), times = 3)
Rep = rep(c("I", "II", "III"), each = 8)
yield = c(22,32,35,55,44,40,60,39,31,43,34,47,45,37,50,41,25,29,50,46,38,36,54,47)
#dataframe
cutting.speed.long = data.frame(factorA, factorB, factorC, Rep, yield)
cutting.aov = aov(yield~Rep+factorA*factorB*factorC, cutting.speed.long)
cutting.aov.og = aov(yield~factorA*factorB*factorC, cutting.speed.long)
summary(cutting.aov); summary(cutting.aov.og)
# creating data table
A <- rep(c("-","+","-","+"), times = 4)
B <- rep(c("-","-","+","+"), times = 4)
Rep <- rep(c("I","II","III","IV"), each = 4)
Vibes <- c(18.2, 27.2, 15.9, 41.0, 18.9, 24.0, 14.5, 43.9, 12.9, 22.4, 15.1, 36.3, 14.4, 22.5, 14.2, 39.9)
router.long <- data.frame(A, B, Rep, Vibes)
for (j in 1:2)
router.long[, j]=as.numeric(coded(router.long[, j]))
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
#######
router.long$Block=router.long$A * router.long$B
router.lm = lm(Vibes ~ Block + A * B, router.long)
router.lm.og = lm(Vibes ~ A * B, router.long)
summary(router.lm); summary(router.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + coded(A)*coded(B)*coded(C)*coded(D), error)#blocking
error.lm.og = lm(UEC ~ coded(A)*coded(B)*coded(C)*coded(D), error)#regular
summary(error.lm); summary(error.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + coded(A)*coded(B)*coded(C)*coded(D), error)#blocking
error.lm.og = lm(UEC ~ coded(A)*coded(B)*coded(C)*coded(D), error)#regular
summary(error.lm); summary(error.lm.og)
for (j in 1:4)
error[, j]=as.numeric(coded(error[, j]))
#Linear Model#
error.lm = lm(UEC ~ Block + coded(A)*coded(B)*coded(C)*coded(D), error)#blocking
error.lm.og = lm(UEC ~ coded(A)*coded(B)*coded(C)*coded(D), error)#regular
summary(error.lm); summary(error.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
# defining coded
for (j in 1:4)
error[, j]=as.numeric(coded(error[, j]))
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
for (j in 1:4)
error[, j]=as.numeric(coded(error[, j]))
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c("+","+","+","-","-","-","+","+","+","-","-","+","-","-","+","-")
B = Pulse.Freq = c("+","-","+","-","+","+","-","-","+","-","-","-","-","+","+","+")
C = Cell.Size = c("+","-","-","-","+","+","-","+","+","+","+","+","-","-","-","-")
D = Writing.Speed = c("-","+","+","+","-","+","-","-","+","+","-","+","-","-","-","+")
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
for (j in 1:4)
error[, j]=as.numeric(coded(error[, j]))
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
#Residual Analysis
res=error$yield-fitted(error.lm)
qqPlot(res)
plot(fitted(error.lm), res)
library(car)
qqPlot(res)
plot(fitted(error.lm), res)
res=error$yield-fitted(error.lm)
qqPlot(res)
plot(fitted(error.lm), res)
#Residual Analysis
res=error$UEC-fitted(error.lm)
qqPlot(res)
plot(fitted(error.lm), res)
res=error$UEC-fitted(error.lm)
qqPlot(res)
plot(fitted(error.lm), res)
res=error$UEC-fitted(error.lm.og)
qqPlot(res)
plot(fitted(error.lm.og), res)
error.lm2 = lm(UEC~ A+C+D, error)
res=error$UEC-fitted(error.lm2)
library(car)
qqPlot(res)
plot(fitted(error.lm2), res)
error.lm2 = lm(UEC~ A+C+D, error)
res=error$UEC-fitted(error.lm2)
library(car)
qqPlot(res)
plot(fitted(error.lm2), res)
#Anova
error.aov = aov(UEC ~ Block + (A)*(B)*(C)*(D), error)
summary(error.aov)
#Anova
error.aov = aov(UEC ~  (A)*(B)*(C)*(D), error)
summary(error.aov)
#############################################
##     Blocking a replicated design         #
#############################################
#Yield data (pp. 234)
yield=read.table("C:/Users/Emmanuel/Desktop/SPRING 2018/Math 447/Chapter 7/yield.txt", header = TRUE)
summary(aov(Yield ~ Rep + A * B, yield)) #analysis of design with blocking
#Anova
error.aov = aov(UEC ~  (A)*(B)*(D), error)
summary(error.aov)
Standard.Order = c(8,10,12,9,7,15,2,6,16,13,5,14,1,3,4,11)
Run.Order = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
A = Laser.Power = c(1,1,1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,-1)
B = Pulse.Freq = c(1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1)
C = Cell.Size = c(1,-1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1)
D = Writing.Speed = c(-1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1)
UEC = c(0.8,0.81,0.79,0.6,0.65,0.55,0.98,0.67,0.69,0.56,0.63,0.65,0.75,0.72,0.98,0.63)
error = data.frame(Standard.Order,Run.Order,A,B,C,D,UEC)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
#Linear Model#
error.lm = lm(UEC ~ Block + (A)*(B)*(C)*(D), error)#blocking
error.lm.og = lm(UEC ~ (A)*(B)*(C)*(D), error)#regular
summary(error.lm); summary(error.lm.og)
#Residual Analysis
res=error$UEC-fitted(error.lm)
qqPlot(res)
plot(fitted(error.lm), res)
coef=error.lm$coefficients[-1]
variables=names(coef)
plot=qqnorm(coef)
variables[identify(plot)]
error.lm2 = lm(UEC ~ Block + A * C * D, error); error.lm2
error.aov = aov(UEC ~ Block + A*C*D, error); error.aov
#Blocking#
error$Block=error$A *error$C * error$D
error.lm2 = lm(UEC ~ Block + A * C * D, error); error.lm2
error.aov = aov(UEC ~ Block + A*C*D, error); error.aov
#Residual Analysis
res=error$UEC-fitted(error.lm2)
qqPlot(res)
plot(fitted(error.lm2), res)
#Blocking#
error$Block=error$A * error$B *error$C * error$D
error.lm2 = lm(UEC ~ Block + A * C * D, error); error.lm2
error.aov = aov(UEC ~ Block + A*C*D, error); error.aov
#Residual Analysis
res=error$UEC-fitted(error.lm2)
qqPlot(res)
plot(fitted(error.lm2), res)
# creating data table
factorA = rep(c("-","+","-","+","-","+","-","+"), times = 3)
factorB = rep(c("-","-","+","+","-","-","+","+"), times = 3)
factorC = rep(c("-","-","-","-","+","+","+","+"), times = 3)
Rep = rep(c("I", "II", "III"), each = 8)
yield = c(22,32,35,55,44,40,60,39,31,43,34,47,45,37,50,41,25,29,50,46,38,36,54,47)
cutting.speed.long = data.frame(factorA, factorB, factorC, Rep, yield)
View(cutting.speed.long)
# creating data table
factorA = rep(c("-","+","-","+","-","+","-","+"), times = 1)
factorB = rep(c("-","-","+","+","-","-","+","+"), times = 1)
factorC = rep(c("-","-","-","-","+","+","+","+"), times = 1)
Rep = rep(c("I"))
yield = c(22,32,35,55,44,40,60,39)
cutting.speed.short = data.frame(factorA, factorB, factorC, Rep, yield)
View(cutting.speed.short)
# defining coded
coded=function(x) #a function to code variable x
{
ifelse(x=="+", 1, -1)
}
cutting.speed.short$Block = cutting.speed.short$factorA * cutting.speed.short$factorB * cutting.speed.short$factorC
cutting.lm = lm(yield ~ Block + factorA * factorB * factorC, cutting.speed.short)
cutting.lm = lm(yield ~ Block + factorA * factorB * factorC, cutting.speed.short)
View(cutting.speed.short)
for (j in 1:3)
filtration[, j]=as.numeric(coded(filtration[, j]))
for (j in 1:3)
cutting.speed.short[, j]=as.numeric(coded(cutting.spped.short[, j]))
for (j in 1:3)
cutting.speed.short[, j]=as.numeric(coded(cutting.speed.short[, j]))
cutting.speed.short$Block = cutting.speed.short$factorA * cutting.speed.short$factorB * cutting.speed.short$factorC
cutting.lm = lm(yield ~ Block + factorA * factorB * factorC, cutting.speed.short)
cutting.lm = lm(yield ~ Block + factorA * factorB * factorC, cutting.speed.short); summary(cutting.lm)
cutting.aov = aov(yield ~ Block + factorA * factorB * factorC, cutting.speed.short); summary(cutting.aov)
